import fsys;
import raw.interface;
import string.cmdline;
import string.encoding;
import process.popen;

var __javaTable__ = ..java;

class java{

	ctor (...){  
		if( self._jvm ){
			return self._jvm;
		}
		
		var vm = ..thread.get("_std.java.vm" )
	 	var result,jniEnv;
		if(!vm){
			if( !__jni_init__() ) {
				return null,"应用程序未包含 JAVA 运行库"; 
			}
			
			var vm_args = getInitArgs(...); 
			vm_args.nOptions = #vm_args.options.array;
			vm_args.options = ..raw.malloc( vm_args.options ); 
			
			if( vm_args.version === null )
				vm_args.version = self.version || 0x00010006/*_JNI_VERSION_1_6*/;
			
			if( vm_args.ignoreUnrecognized === null )
				vm_args.ignoreUnrecognized = 1/*_JNI_TRUE*/;
			
			result,vm,jniEnv = JNI_CreateJavaVM(null, null,vm_args);
			if (result < 0) { 
				error( "Can't create Java VM,Result:" + result,2);
				return;
			} 
			 
			this.__isMainThread = true;
			..thread.set("_std.java.vm",vm )  
		}
		else {
			this.__isMainThread = false; 
		}
		 
		
		if( !vm ) {
			error( "Can't create Java VM(2) " ,2);
		}   
		this.vm = ..raw.interface( vm,JavaVM ) 
		
		result,jniEnv = this.vm.AttachCurrentThread(); 
		if( !jniEnv ) {
			error( "Can't attach current thread to Java VM,Result:" + result,2);
		}   
		this.env = ..raw.interface(jniEnv,JNIEnv );
		this.version = this.env.GetVersion();
		jniEnv = this.env;
		
		..table.add_gc(this,
			function(){  
				if(jniEnv){
					this.vm.DetachCurrentThread();
					//this.vm.DestroyJavaVM(); 
					this.env = null;
					this.vm = null;
					jniEnv = null;
				}
			} 
		); 
  
		this._javaClasses  = { @{_weak="kv"}};
		self._jvm = this;
		this.exceptionClear = function(){
			if ( jniEnv.ExceptionCheck() == 1/*_JNI_TRUE*/ ) {
            	 
            	var err;
            	var ex = jniEnv.ExceptionOccurred();
            	
            	//打印错误信息，之后就取不到 ExceptionOccurred
            	jniEnv.ExceptionDescribe(); 
            	
            	//必须清除异常，不然所有 JNI 接口都无法使用
            	jniEnv.ExceptionClear(); 
            	
            	if(ex){
            		ex = ..java.object(this,ex);
            		err = ex.getMessage();
            		
            		ex._jvm_deleteDeleteGlobalRef();
            	}
        		
        		return true,err; 
        	} 
		}; 
		
		this.interop = ..java.class(this,"aardio.interopServices.utility"
			,this.__isMainThread ? $"~\lib\java\.interopServices\utility.class" : null ) 
		this.fieldExists = this.interop.getMethod("fieldExists","bool(pointer[])");
		this.getFieldValue__ = this.interop.getMethod("getFieldValue","pointer(pointer[])");
		this.setFieldValue__ = this.interop.getMethod("setFieldValue","void(pointer[])");
		this.invokeMethod__ = this.interop.getMethod("invokeMethod","pointer(pointer[])");
		this.new = this.interop.getMethod("createInstance","pointer(pointer[])");
		this.objectIsNumber  = this.interop.getMethod("objectIsNumber","bool(pointer)");
		this.objectIsString = this.interop.getMethod("objectIsString","bool(pointer)");
		this.objectIsStringArray = this.interop.getMethod("objectIsStringArray","bool(pointer)");
		this.objectIsNummberArray = this.interop.getMethod("objectIsNummberArray","bool(pointer)");
		this.objectIsBuffer = this.interop.getMethod("objectIsByteArray","bool(pointer)");
		this.objectIsHashMap = this.interop.getMethod("objectIsHashMap","bool(pointer)");
		this.objectIsMap = this.interop.getMethod("objectIsMap","bool(pointer)");
		this.objectIsCollection = this.interop.getMethod("objectIsCollection","bool(pointer)");
		this.objectIsArrayList = this.interop.getMethod("objectIsArrayList","bool(pointer)");			
				
		this.object2Number  = this.interop.getMethod("object2Number","double(pointer)");
		this.object2String = this.interop.getMethod("object2String","string(pointer)");
		this.object2StringArray = this.interop.getMethod("object2StringArray","string[](pointer)");
		this.object2NumberArray  = this.interop.getMethod("object2NumberArray","double[](pointer)");
		this.object2Boolean = this.interop.getMethod("object2Boolean","bool(pointer)");
		this.objectTypecode = this.interop.getMethod("objectTypecode","int(pointer)");
		
		this.invokeMethod = function(obj,...){
			var obj,errMessage = this.invokeMethod__(obj,...);
			if( obj ) {   
				var t = this.objectTypecode(obj);
				if( t == 1 ) return this.object2String(obj);
				if( t == 2 ) return this.object2Number(obj); 
				if( t == 3 ) return this.object2StringArray(obj); 
				if( t == 4 ) return this.object2NumberArray(obj);
				if( t == 5 ) return this.parseBuffer(obj);
				if( t == 6 ) return this.object2Boolean(obj);
				if( t == 7 ) return ..time( (obj.getTime()/1000) );
				//8 为 Map , 9 为 Collection
				
				//调用程序请不要使用 $jvmTypeCode，后续可能会变更
				obj[["$jvmTypeCode"]] = typecode;
				return obj; 
			}
			
			return obj,errMessage;
		}
		this.getFieldValue = function(...){
			var obj = this.getFieldValue__(...);
			if( obj ) {
				 
				var t = this.objectTypecode(obj);
				if( t == 1 ) return this.object2String(obj);
				if( t == 2 )  return this.object2Number(obj); 
				if( t == 3 ) return this.object2StringArray(obj); 
				if( t == 4 ) return this.object2NumberArray(obj);
				if( t == 5 ) return this.parseBuffer(obj);
				if( t == 6 ) return this.object2Boolean(obj);
				if( t == 7 ) return ..time( (obj.getTime()/1000) );
				
				//调用程序请不要使用 $jvmTypeCode，后续可能会变更
				obj[["$jvmTypeCode"]] = typecode;
				return obj; 
			}
			return obj;
		}
		this.setFieldValue = function(obj,k,v){
			this.setFieldValue__( obj,k,v );
		}
		
		this.import =  function(classPath,clssBuffer,classLoader){
			return ..java.class(this,classPath,clssBuffer,classLoader);	
		};
		
		this.jObjectClass = this.import("java.lang.Object");
		this.jBooleanClass = this.import("java.lang.Boolean");
		this.jIntegerClass = this.import("java.lang.Integer");
		this.jShortClass = this.import("java.lang.Short");
		this.jCharacterClass = this.import("java.lang.Character");
		this.jByteClass = this.import("java.lang.Byte");
		this.jLongClass = this.import("java.lang.Long");
		this.jFloatClass = this.import("java.lang.Float");
		this.jDoubleClass = this.import("java.lang.Double");
		this.jStringClass = this.import("java.lang.String"); 
		this.jNetUrlClass = this.import( "java.net.URL");
		this.jHashMapClass = this.import( "java.util.HashMap"); 
		this.jDateClass = this.import( "java.util.Date");
		
		this.jFileInputStreamClass = this.import("java.io.FileInputStream");
		this.jObjectInputStreamClass = this.import("java.io.ObjectInputStream");
  
		this.loadFileObject = function(path){
			var input = this.jFileInputStreamClass(path);
			if(input){
 				var stream = this.jObjectInputStreamClass(input);
 				if(stream){
 					var r = stream.readObject();;
 					stream.close();
 					return r;
 				}
			}
		} 
	};
	string = function(str){
		var jInstance = jniEnv.NewStringUTF((tostring(str)));
		if (!jInstance) { 
            this.exceptionClear();
            return;
		}
		
		return ..java.object(this, jInstance );
	};
	double = function(v){
		return this.jDoubleClass.new2("void(double)",v);
	};
	float = function(v){
		return this.jFloatClass.new2("void(float)",v);
	};
	long = function(v){
		return this.jLongClass.new2("void(long)",v);
	};
	char = function(v){
		return this.jCharacterClass.new2("void(char)",v);
	};
	byte = function(v){
		return this.jByteClass.new2("void(byte)",v);
	}; 
	short = function(v){
		return this.jShortClass.new2("void(short)",v);
	};
	int = function(v){
		return this.jIntegerClass.new2("void(int)",v);
	};
	boolean = function(v){
		return this.jBooleanClass.new2("void(boolean)",v);
	};		
	hashMap = function(tab){
		var jMap = this.jHashMapClass.new()
		for(k,v in tab){
			jMap.put(k,v);
		}
		return jMap;
	}; 
	date = function(v){ 
		return this.jDateClass.new2( "void(long)",(tonumber(v === null ?..time() : v))*1000) 
	}
	object = function(v){
		var t = type(v);
		if(t == "table"){
			if(v@ && v@._topointer && (v.$jvmInstancePtr || v.$jvmClassPtr)){
				return v;	
			}
			elseif( #v ) {
				if(type(v[1]==="string")){ 
					return this.stringArray(v);
				}
				else { 
					return this.array("pointer",v);
				} 
			} 
			elseif( ..table.isArray(v) ){
				return this.array("pointer",{});
			}
			elseif(..time.istime(v)){
				return this.date(v);
			}
			else{
				return this.hashMap(v);
			}
		}
		elseif(t == "string"){ 
			return this.string(v); 
		}
		elseif(t == "number"){
			return this.double(v);
		}
		elseif(t == "boolean"){
			return this.boolean(v);
		} 
		elseif(t == "buffer"){ 
			return this.buffer(v);
		}	
	};
	array = function(atype,...){ 
		
		var arr = ...
		if(type(arr)!="table" || (arr@ ? arr@._topointer) ){
			arr = {...}
		} 
		
		var jniResultType = signatureTypeToJniType(atype)
		
		if( jniResultType == "Object" ){
			var t;
			var jarr = jniEnv.NewObjectArray( #arr,this.jObjectClass); 
			for(i=1;#arr;1){
				t = type(arr[i]);
				if(t == "string"){ 
					var jstr = this.string(arr[i]);
					jniEnv.SetObjectArrayElement(jarr,i-1,jstr);
				}
				elseif(t == "table"){
					if(arr[i]@ && arr[i]@._topointer){
						jniEnv.SetObjectArrayElement(jarr,i-1,arr[i]);	
					}
					elseif( #(arr[i]) ) {
						if(type(arr[i][1]==="string")){ 
							jniEnv.SetObjectArrayElement(jarr,i-1,this.stringArray(arr[i]));
						}
						else { 
							jniEnv.SetObjectArrayElement(jarr,i-1,this.array("pointer",arr[i]));
						} 
					} 
					elseif( ..table.isArray(arr[i]) ){
						jniEnv.SetObjectArrayElement(jarr,i-1,this.array("pointer",{}));
					}
					elseif(..time.istime(arr[i])){ 
						jniEnv.SetObjectArrayElement(jarr,i-1,this.date(arr[i]));
					}
					else{
						jniEnv.SetObjectArrayElement(jarr,i-1,this.hashMap(v));
					}
				}
				elseif(t == "number"){
					jniEnv.SetObjectArrayElement(jarr,i-1,this.double(arr[i]));
				}
				elseif(t == "boolean"){
					jniEnv.SetObjectArrayElement(jarr,i-1,this.boolean(arr[i]));
				} 
				elseif(t == "buffer"){ 
					jniEnv.SetObjectArrayElement(jarr,i-1,this.buffer(arr[i]));
				}
			}
			return ..java.object(this,jarr);
		}
		
		var newArray = jniEnv[  ..string.format("New%sArray",jniResultType) ]
		var setArray = jniEnv[  ..string.format("Set%sArrayRegion",jniResultType) ] 
		if(! (newArray && setArray) )
			error("错误的数组类型" + atype ,2)
			
		var jarr = newArray(#arr);
		setArray(jarr,0,#arr,..raw.toarray( arr ,atype,"array" )) 
		return ..java.object(this,jarr);
	};
	buffer = function(buf){
		var jbytes = jniEnv.NewByteArray(#buf);
		jniEnv.SetByteArrayRegion(jbytes,0,#buf,buf) 
		return ..java.object(this,jbytes);	
	};
	stringArray = function(...){ 
		var args = ...
		if(type(args)!=type.table)
			args = {...};
		
		if(!args){
			error("参数不能为空",2);
		} 
		
		var array = jniEnv.NewObjectArray(#args, this.jStringClass );
		var jstr;
		for(i=1;#args;1){ 
			jstr = tostring( args[i] )
			jstr = this.string( args[i] );
			if(!jstr) error("创建字符串对象失败",2)
				 
		    jniEnv.SetObjectArrayElement(array, i-1,jstr  );
        	if ( this.exceptionClear() ) { 
            	error("创建字符串数组失败",2);
        	}

		}
		return ..java.object(this,array);

	}; 
	parseBuffer = function(jbuffer){
		 
		var len = jniEnv.GetArrayLength(jbuffer)
		if(!len) return null;
	
		var buffer = ..raw.buffer(len);
		jniEnv.GetByteArrayRegion(jbuffer,0,len,buffer) 
		
		jniEnv.DeleteLocalRef(jbuffer);
		return buffer;
	};
	parseString = function(jstr){
		if(!jstr) return;
		var pstr = jniEnv.GetStringUTFChars(jstr, 0);
		if (!pstr) { 
			jniEnv.DeleteLocalRef(jstr);
            this.exceptionClear();
            return;
		}
		var len = jniEnv.GetStringUTFLength(jstr);
		var str = ..raw.tostring(pstr,1,len); 
		
		jniEnv.ReleaseStringUTFChars(jstr,pstr);
		jniEnv.DeleteLocalRef(jstr);
		return str; 
	};
	parseArray = function(atype,jarr){
		if( type(atype) != "string") error("参数一必须是字符串指定的类型名",3);
		
		if(atype=="string") return this.parseStringArray(jarr);
		var len = jniEnv.GetArrayLength(jarr)
		if(!len){
			jniEnv.DeleteLocalRef(jarr);
			return {};
		}
	
		var jniResultType = signatureTypeToJniType(atype) 
		if( jniResultType == "Object" ){ 
			var array = [];
			for(i=1;len;1){
				array[i] = ..java.object(this,jniEnv.GetObjectArrayElement(jarr,i-1));
			} 
			
			jniEnv.DeleteLocalRef(jarr);
			return array;
		}
		
		var arrayGetter = jniEnv[  ..string.format("Get%sArrayRegion",jniResultType) ];
		if(! arrayGetter ){ 
			jniEnv.DeleteLocalRef(jarr);
			error("错误的数组类型" + atype ,2)
		}
		
		var rawArray = ..raw.toarray(len,atype,"items");
		arrayGetter(jarr,0,len,rawArray) 
		
		jniEnv.DeleteLocalRef(jarr);
		return rawArray.items;
	};
	parseStringArray = function(jarr){
		var len = jniEnv.GetArrayLength(jarr)
		if(!len){
			jniEnv.DeleteLocalRef(jarr);
			return {};
		}
		
		var array = {};
		for(i=1;len;1){
			array[i] = this.parseString(jniEnv.GetObjectArrayElement(jarr,i-1));
		} 
		
		jniEnv.DeleteLocalRef(jarr);
		return array;
	};
	parseObject = function(jInstance){
		return ..java.object(this, jInstance );
	};
	getClassLoader = function(){ 
		if( this.version >= 0x90000/*_JNI_VERSION_9*/ ) return;
		if( this.classLoader !== null ) return this.classLoader;
		 
		var getCurrentThread = this.import("java.lang.Thread").getMethod("currentThread","java.lang.Thread()" );
		var curThread = getCurrentThread();
		var getContextClassLoader = curThread.getMethod("getContextClassLoader","java.lang.ClassLoader()" )
		var classLoader = getContextClassLoader();
		
		if( !classLoader ){ 
			var getSystemClassLoader = this.import("java.net.URLClassLoader").getMethod("getSystemClassLoader","java.lang.ClassLoader()");
			classLoader = getSystemClassLoader();
		}
		 
		var addURL;
		try{
			addURL = classLoader.getMethod( "addURL","void(java.net.URL)" );
			this.classLoader = classLoader;
		}
		if(!addURL) {
			this.classLoader = false;
			return false;
		}
		
		classLoader[["addUrl"]] = function(path){
			if(!#path) return;
			if( ! ..string.match(path,"^\w+\:\/\/") ){ 
				var shortPath = ..io.exist(path) && ..fsys.shortpath(path);   
				if( shortPath ){
					path = ..io.fullpath(path);
					if( ..fsys.isDir(path) ){
						path = ..fsys.path.addBackslash(path);
					} 
					path = "file:///" + path;
				}
				else {
					error("错误的路径",2)
				}
				
			}
			
			if( __globalClassLoadedPaths[path] ) { return; }
			__globalClassLoadedPaths[path] = true;
			
			var url = this.jNetUrlClass.new2("void(string)" ,path); 
			addURL(url);//该java函数有自动去重功能(但不忽略大小写) 
		};
		classLoader[["addUrls"]] = function(urls,...){
			if( type(urls) != "table" ) urls = {urls;...};
			for(i=1;#urls;1){
				owner.addUrl(urls[i]); 
			} 	
		}
		
		return classLoader; 
	};
	addClassLoaderUrl = function(...){
		var loader = this.getClassLoader();
		if(loader) return loader.addUrls(...);
		else {
			error("Java 9 以上不支持此功能",2)
		} 
	};
	reopen = function(funcName,filename){
		var outstream = this.import( "java.io.FileOutputStream")( ..io.fullpath(filename) ); 
		var printstream = this.import("java.io.PrintStream").new2("void(java.io.OutputStream)",outstream)	 
		var reset = this.import("java.lang.System").getMethod(funcName);	
		reset(printstream);
	};
	__jvm_init__(this) and null;
}

if( __javaTable__ ) ..table.mix( java/*class*/,__javaTable__/*table*/);

import java.path;
/*
import java.jdk.v8;
import java.jre.v8;
*/

namespace java {  
	encoding = "utf-8";
	
	_classPaths = {"/";"/java/";..io.fullpath( "~/java/") }
	_libPaths = {"/java/";..io.fullpath( "~/java/") }

	addClassPath = function(...){ 
		..table.push(_classPaths,...) 
	};
	addLibPath = function(...){ 
		..table.push(_libPaths,...) 
	};
	getLibPathCommand = function(...){ 
		var libPath;
		var argLp = {...};  
		for(i=1;#_libPaths){ 
			libPath = ..io.exist(_libPaths[i]);
			if(libPath)..table.push(argLp,libPath )
		}
		
		for(k,path in argLp){ 
			argLp[k] = ..fsys.shortpath(path);
		}
		return ..string.join(argLp,";" )
	};
	 
	__prepareLocalClassPaths = function(...){ 
		if( __localClassPaths ) return __localClassPaths;
		__localClassPaths  = {...};
		
		var searchJar = function(dir){
			var dir = ..io.exist(dir)
			if( dir ) {
				..table.push( __localClassPaths ,dir);
				if(..fsys.isDir(dir)){
					..fsys.enum( dir, 
								"*.jar", 
								function(dir,file,fullpath,findData){ 
									if(file){  
		           						..table.push( __localClassPaths ,fullpath )
									} 
								},false //不搜索子目录
				  			); 	
				}
				
			}	
		} 
		for(i=1;#_classPaths){
			searchJar(_classPaths[i])
		}
		
		for(k,path in __localClassPaths ){ 
			__localClassPaths [k] = ..fsys.shortpath(path);
		}
		return __localClassPaths;
	};	
	getClassPathCommand = function( cmd ,... ){
		var args =  ..string.join( __prepareLocalClassPaths(...) ,";" )
		if( cmd ) args = cmd +  ";" + args;
		return args;
	};
 
	//__globalClassLoadedPaths = null; 
	__jvm_init__ = function(jvm){
	
		..subscribe("afterConsoleOpen",function(){
		 	jvm.reopen("setErr","conerr$");
			jvm.reopen("setOut","conout$");
		} );
		
		if( jvm.__isMainThread ){
			__globalClassLoadedPaths = __localClassPaths;
			..thread.set("_std.java.vm.loadedPaths", __globalClassLoadedPaths);
			
			if( jvm.version < 0x90000/*_JNI_VERSION_9*/ && ..io.exist("/java/") ) {
				jvm.addClassLoaderUrl("/java/");
				..fsys.enum("/java/", "*.jar",
					function(dirname,filename,fullpath){ 
						if(filename) jvm.addClassLoaderUrl(fullpath);
					},false
				);
			}
		}
		else {
			__globalClassLoadedPaths = ..thread.get("_std.java.vm.loadedPaths" );
			__localClassPaths = __prepareLocalClassPaths();
		};
	}
	
	//%JAVA_TOOL_OPTIONS%
	//-D<propertyName>=value 在程序中可以使用 System.getProperty("propertyName") 得到value的值
	getInitArgs = function(...){
		var args = ...;
		if( args[["options"]] ){ 
			return args;
		}
		
		var args = ..table.append({"-Djava.compiler=NONE";
			 ..string.fromto(getClassPathCommand( "-Djava.class.path=."),65001,0);
			 ..string.fromto( getLibPathCommand("-Djava.library.path=.") ,65001,0)
			},..string.cmdline.arguments(...));
	 
	 	if(self.encoding){
	 		..table.unshift(args,"-Dfile.encoding="+self.encoding);
	 	}
	 	 
		var vm_args = InitArgs();
		//JNI_GetDefaultInitArgs(vm_args); 
		vm_args.options = {
			struct array[] = {};
		} 
		
		for(i=1;#args;1){ 
			vm_args.options.array[i] = VmOption( args[i] ); 
		} 
		return vm_args;
	}  
	__openProcess = function(process,exeFile,args,...){
		 
		var binPath = ..java.path.jreBin();
		if(!binPath) return null,"没有找到Java运行库"; 
		
		binPath = ..io.joinpath(binPath,exeFile);
		if( ! ..io.exist(binPath) ) return null,"没有找到" + exeFile;

		var args,startInfo = ..string.cmdline.arguments(args,...);
		..table.unshift(args,"-Dfile.encoding="+self.encoding,"-classpath",getClassPathCommand( "%CLASSPATH%" ) ); 
		
		var prcs,err = process(binPath,args,startInfo );
		if( prcs && self.encoding){
			prcs.codepage = ..string.encoding.getCodepage(self.encoding);
		}
		return prcs,err; 
	};
	openProcess = function(...){
		return __openProcess(..process,"javaw.exe",...);	
	};
	popenProcess = function(...){
		return __openProcess(..process.popen,"java.exe",...);	
	};
	runtimeVersion = function(major){
		var prcs = popenProcess("-version");
		if(prcs) {
			var v = prcs.readAll(`.+version\s+\"([\d\.]+)`);
			if(major){
				var nums = ..string.map(v);
				if(nums[1]===1) return nums[2]
				return nums[1];
			}
			
			return v;
		}
	};
	compilerVersion = function(){
		var prcs = compile("-version");
		if(prcs) return prcs.readAll("[\d._]+\d");	
	};
	compile = function(filepath,...){
		var args = ..string.cmdline.arguments(...);
		..table.push(args, "-classpath",getClassPathCommand( "." ) );
		if(self.encoding){
			..table.push(args,"-encoding",self.encoding,"-J-Dfile.encoding="+self.encoding);
			
		}
		
		if(!filepath) error("请指定参数@1",2)
		if(filepath[1]!='-'#){
			..table.push(args, ..io.localpath(filepath) : filepath )
		}
		else {
			..table.unshift(args,filepath);
		}
		
		var javac = ..java.path.jdkCompiler(); 
		if( javac ){ 
			var prcs,err = ..process.popen(javac,args)
			if( prcs && self.encoding){
				prcs.codepage = ..string.encoding.getCodepage(self.encoding);
			}
			
			return prcs,err;
		}
		else{
			error('找不到javac.exe\n当前系统尚未安装Java开发环境',2)
		}
	};
	__jni_init__ = function(){
		if(JNI_CreateJavaVM) return;   
		var jvmPath = ..java.path.jvm();

		if(!jvmPath)  return; 
		   
		..fsys.setCurDir(..java.path.jvmBin()); 

		var jvm;
		try{ jvm = ..raw.loadDll( jvmPath  ) }
		..fsys.setCurDir("/");
		
		if(!jvm) return; 		

		JNI_GetDefaultJavaVMInitArgs = jvm.api("JNI_GetDefaultJavaVMInitArgs","int(struct &args)" )
		JNI_CreateJavaVM = jvm.api("JNI_CreateJavaVM","int(pointer &pvm,pointer &penv,struct args)" )
		JNI_GetCreatedJavaVMs = jvm.api("JNI_GetCreatedJavaVMs","int(pointer &pvm,int size,int & sizeout)" )
		
			
		return true;
	}
	
	class InitArgs {
    	int version;
		int nOptions;
    	pointer options;
    	BYTE ignoreUnrecognized;
	};
	
	class VmOption {
		ctor(str,extra){
			this.optionString = str;
			this.extraInfo = extra;
		}
    	string optionString;
    	pointer extraInfo;
	}
	
	class JavaVM{ //
    	pointer reserved0;
    	pointer reserved1;
    	pointer reserved2;
		pointer DestroyJavaVM = "int()";
		pointer AttachCurrentThread = "int(pointer &evn,pointer args)";
		pointer DetachCurrentThread = "int()"; 
		pointer GetEnv = "int(pointer &evn,int version)";
		pointer AttachCurrentThreadAsDaemon = "int(pointer &evn,pointer args)"; 
	} 
	
	class JNIEnv { //
		pointer reserved0;
		pointer reserved1;
		pointer reserved2; 
		pointer reserved3;
		pointer GetVersion = "int()";
		pointer DefineClass = "pointer(STRING name,pointer loader,pointer buf,int len)";
		pointer FindClass = "pointer(STRING name)";
		pointer FromReflectedMethod = "pointer(POINTER method)";
		pointer FromReflectedField = "pointer(POINTER field)";
		pointer ToReflectedMethod = "pointer(POINTER cls,pointer methodID,BYTE isStatic)";
		pointer GetSuperclass = "pointer(POINTER sub)";
		pointer IsAssignableFrom = "BYTE(POINTER sub,pointer sup)";
		pointer ToReflectedField = "pointer(POINTER cls,pointer fieldID,BYTE isStatic)";
		pointer Throw = "int(POINTER obj)";
		pointer ThrowNew = "int(POINTER clazz,string msg)";
		pointer ExceptionOccurred = "pointer()";
		pointer ExceptionDescribe = "void()";
		pointer ExceptionClear = "void()";
		pointer FatalError = "void(string msg)";
		pointer PushLocalFrame = "int(int capacity)";
		pointer PopLocalFrame = "pointer(POINTER result)";
		pointer NewGlobalRef = "pointer(POINTER lobj)";
		pointer DeleteGlobalRef = "void(POINTER gref)";
		pointer DeleteLocalRef = "void(POINTER obj)";
		pointer IsSameObject = "BYTE(POINTER obj1,pointer obj2)";
		pointer NewLocalRef = "pointer(POINTER ref)";
		pointer EnsureLocalCapacity = "int(int capacity)";
		pointer AllocObject = "pointer(POINTER clazz)";
		pointer NewObject = ""; //= "pointer(POINTER clazz,pointer methodID,...)";
		pointer NewObjectV = "pointer(POINTER clazz,pointer methodID,struct args)";
		pointer NewObjectA =  "pointer(POINTER clazz,pointer methodID,struct args)";
		pointer GetObjectClass = "pointer(POINTER obj)";
		pointer IsInstanceOf = "BYTE(POINTER obj,pointer clazz)";
		pointer GetMethodID = "pointer(POINTER clazz,STRING name,string sig)";
		pointer CallObjectMethod ; //= "pointer(POINTER obj,pointer methodID,...)";
		pointer CallObjectMethodV = "pointer(POINTER obj,pointer methodID,struct args)";
		pointer CallObjectMethodA = "pointer(POINTER obj,pointer methodID,struct args)";
		pointer CallBooleanMethod ; //= "BYTE(POINTER obj,pointer methodID,...)";
		pointer CallBooleanMethodV = "bool(POINTER obj,pointer methodID,struct args)";
		pointer CallBooleanMethodA = "bool(POINTER obj,pointer methodID,struct args)";
		pointer CallByteMethod ; //= "byte(POINTER obj,pointer methodID,...)";
		pointer CallByteMethodV = "byte(POINTER obj,pointer methodID,struct args)";
		pointer CallByteMethodA = "byte(POINTER obj,pointer methodID,struct args)";
		pointer CallCharMethod ; //= "WORD(POINTER obj,pointer methodID,...)";
		pointer CallCharMethodV = "WORD(POINTER obj,pointer methodID,struct args)";
		pointer CallCharMethodA = "WORD(POINTER obj,pointer methodID,struct args)";
		pointer CallShortMethod ; //= "BYTE(POINTER obj,pointer methodID,...)";
		pointer CallShortMethodV = "BYTE(POINTER obj,pointer methodID,struct args)";
		pointer CallShortMethodA = "BYTE(POINTER obj,pointer methodID,struct args)";
		pointer CallIntMethod ; //= "int(POINTER obj,pointer methodID,...)";
		pointer CallIntMethodV = "int(POINTER obj,pointer methodID,struct args)";
		pointer CallIntMethodA = "int(POINTER obj,pointer methodID,struct args)";
		pointer CallLongMethod ; //= "long(POINTER obj,pointer methodID,...)";
		pointer CallLongMethodV = "long(POINTER obj,pointer methodID,struct args)";
		pointer CallLongMethodA = "long(POINTER obj,pointer methodID,struct args)";
		pointer CallFloatMethod ; //= "float(POINTER obj,pointer methodID,...)";
		pointer CallFloatMethodV = "float(POINTER obj,pointer methodID,struct args)";
		pointer CallFloatMethodA = "float(POINTER obj,pointer methodID,struct args)";
		pointer CallDoubleMethod ; //= "double(POINTER obj,pointer methodID,...)";
		pointer CallDoubleMethodV = "double(POINTER obj,pointer methodID,struct args)";
		pointer CallDoubleMethodA = "double(POINTER obj,pointer methodID,struct args)";
		pointer CallVoidMethod ; //= "void(POINTER obj,pointer methodID,...)";
		pointer CallVoidMethodV = "void(POINTER obj,pointer methodID,struct args)";
		pointer CallVoidMethodA = "void(POINTER obj,pointer methodID,struct args)";
		pointer CallNonvirtualObjectMethod ; //= "pointer(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualObjectMethodV = "pointer(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualObjectMethodA = "pointer(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualBooleanMethod ; //= "BYTE(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualBooleanMethodV = "BYTE(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualBooleanMethodA = "BYTE(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualByteMethod ; //= "byte(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualByteMethodV = "byte(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualByteMethodA = "byte(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualCharMethod ; //= "WORD(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualCharMethodV = "WORD(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualCharMethodA = "WORD(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualShortMethod ; //= "BYTE(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualShortMethodV = "BYTE(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualShortMethodA = "BYTE(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualIntMethod ; //= "int(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualIntMethodV = "int(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualIntMethodA = "int(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualLongMethod ; //= "long(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualLongMethodV = "long(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualLongMethodA = "long(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualFloatMethod ; //= "float(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualFloatMethodV = "float(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualFloatMethodA = "float(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualDoubleMethod ; //= "double(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualDoubleMethodV = "double(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualDoubleMethodA = "double(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualVoidMethod ; //= "void(POINTER obj,pointer clazz,pointer methodID,...)";
		pointer CallNonvirtualVoidMethodV = "void(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer CallNonvirtualVoidMethodA = "void(POINTER obj,pointer clazz,pointer methodID,struct args)";
		pointer GetFieldID = "pointer(POINTER clazz,STRING name,string sig)";
		pointer GetObjectField = "pointer(POINTER obj,pointer fieldID)";
		pointer GetBooleanField = "BYTE(POINTER obj,pointer fieldID)";
		pointer GetByteField = "byte(POINTER obj,pointer fieldID)";
		pointer GetCharField = "WORD(POINTER obj,pointer fieldID)";
		pointer GetShortField = "BYTE(POINTER obj,pointer fieldID)";
		pointer GetIntField = "int(POINTER obj,pointer fieldID)";
		pointer GetLongField = "long(POINTER obj,pointer fieldID)";
		pointer GetFloatField = "float(POINTER obj,pointer fieldID)";
		pointer GetDoubleField = "double(POINTER obj,pointer fieldID)";
		pointer SetObjectField = "void(POINTER obj,pointer fieldID,pointer val)";
		pointer SetBooleanField = "void(POINTER obj,pointer fieldID,BYTE val)";
		pointer SetByteField = "void(POINTER obj,pointer fieldID,byte val)";
		pointer SetCharField = "void(POINTER obj,pointer fieldID,WORD val)";
		pointer SetShortField = "void(POINTER obj,pointer fieldID,BYTE val)";
		pointer SetIntField = "void(POINTER obj,pointer fieldID,int val)";
		pointer SetLongField = "void(POINTER obj,pointer fieldID,long val)";
		pointer SetFloatField = "void(POINTER obj,pointer fieldID,float val)";
		pointer SetDoubleField = "void(POINTER obj,pointer fieldID,double val)";
		pointer GetStaticMethodID = "pointer(POINTER clazz,STRING name,string sig)";
		pointer CallStaticObjectMethod ; //= "pointer(POINTER clazz,pointer methodID,...)";
		pointer CallStaticObjectMethodV = "pointer(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticObjectMethodA = "pointer(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticBooleanMethod ; //= "bool(POINTER clazz,pointer methodID,...)";
		pointer CallStaticBooleanMethodV = "bool(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticBooleanMethodA = "bool(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticByteMethod ; //= "byte(POINTER clazz,pointer methodID,...)";
		pointer CallStaticByteMethodV = "byte(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticByteMethodA = "byte(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticCharMethod ; //= "WORD(POINTER clazz,pointer methodID,...)";
		pointer CallStaticCharMethodV = "WORD(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticCharMethodA = "WORD(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticShortMethod ; //= "BYTE(POINTER clazz,pointer methodID,...)";
		pointer CallStaticShortMethodV = "BYTE(POINTER clazz,pointer methodID,struct  args)";
		pointer CallStaticShortMethodA = "BYTE(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticIntMethod ; //= "int(POINTER clazz,pointer methodID,...)";
		pointer CallStaticIntMethodV = "int(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticIntMethodA = "int(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticLongMethod ; //= "long(POINTER clazz,pointer methodID,...)";
		pointer CallStaticLongMethodV = "long(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticLongMethodA = "long(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticFloatMethod ; //= "float(POINTER clazz,pointer methodID,...)";
		pointer CallStaticFloatMethodV = "float(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticFloatMethodA = "float(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticDoubleMethod ; //= "double(POINTER clazz,pointer methodID,...)";
		pointer CallStaticDoubleMethodV = "double(POINTER clazz,pointer methodID,struct args)";
		pointer CallStaticDoubleMethodA = "double(POINTER clazz,pointer methodID,struct jvalue)";
		pointer CallStaticVoidMethod ; //= "void(POINTER cls,pointer methodID,...)";
		pointer CallStaticVoidMethodV = "void(POINTER cls,pointer methodID,struct args)";
		pointer CallStaticVoidMethodA = "void(POINTER cls,pointer methodID,struct args)";
		pointer GetStaticFieldID = "pointer(POINTER clazz,STRING name,string sig)";
		pointer GetStaticObjectField = "pointer(POINTER clazz,pointer fieldID)";
		pointer GetStaticBooleanField = "BYTE(POINTER clazz,pointer fieldID)";
		pointer GetStaticByteField = "byte(POINTER clazz,pointer fieldID)";
		pointer GetStaticCharField = "WORD(POINTER clazz,pointer fieldID)";
		pointer GetStaticShortField = "BYTE(POINTER clazz,pointer fieldID)";
		pointer GetStaticIntField = "int(POINTER clazz,pointer fieldID)";
		pointer GetStaticLongField = "long(POINTER clazz,pointer fieldID)";
		pointer GetStaticFloatField = "float(POINTER clazz,pointer fieldID)";
		pointer GetStaticDoubleField = "double(POINTER clazz,pointer fieldID)";
		pointer SetStaticObjectField = "void(POINTER clazz,pointer fieldID,pointer value)";
		pointer SetStaticBooleanField = "void(POINTER clazz,pointer fieldID,BYTE value)";
		pointer SetStaticByteField = "void(POINTER clazz,pointer fieldID,byte value)";
		pointer SetStaticCharField = "void(POINTER clazz,pointer fieldID,WORD value)";
		pointer SetStaticShortField = "void(POINTER clazz,pointer fieldID,BYTE value)";
		pointer SetStaticIntField = "void(POINTER clazz,pointer fieldID,int value)";
		pointer SetStaticLongField = "void(POINTER clazz,pointer fieldID,long value)";
		pointer SetStaticFloatField = "void(POINTER clazz,pointer fieldID,float value)";
		pointer SetStaticDoubleField = "void(POINTER clazz,pointer fieldID,double value)";
		pointer NewString = "pointer (POINTER unicode,int len)";
		pointer GetStringLength = "int(POINTER  str)";
		pointer GetStringChars = "pointer(POINTER  str,BYTE &isCopy)";
		pointer ReleaseStringChars = "void(POINTER  str,pointer chars)";
		pointer NewStringUTF = "pointer (string utf)";
		pointer GetStringUTFLength = "int(POINTER  str)";
		pointer GetStringUTFChars = "pointer (POINTER  str,BYTE &isCopy)";
		pointer ReleaseStringUTFChars = "void(POINTER  str,pointer  chars)";
		pointer GetArrayLength = "int(POINTER array)";
		pointer NewObjectArray = "pointer(int len,pointer clazz,pointer init)";
		pointer GetObjectArrayElement = "pointer(POINTER array,int index)";
		pointer SetObjectArrayElement = "void(POINTER array,int index,pointer val)";
		pointer NewBooleanArray = "pointer(int len)";
		pointer NewByteArray = "pointer(int len)";
		pointer NewCharArray = "pointer(int len)";
		pointer NewShortArray = "pointer(int len)";
		pointer NewIntArray = "pointer(int len)";
		pointer NewLongArray = "pointer(int len)";
		pointer NewFloatArray = "pointer(int len)";
		pointer NewDoubleArray = "pointer(int len)"; 
		pointer GetBooleanArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetByteArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetCharArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetShortArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetIntArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetLongArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetFloatArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer GetDoubleArrayElements = "pointer(POINTER array,BYTE &isCopy)";
		pointer ReleaseBooleanArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseByteArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseCharArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseShortArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseIntArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseLongArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseFloatArrayElements = "void(POINTER array,pointer elems,int mode)";
		pointer ReleaseDoubleArrayElements = "void(POINTER array,pointer elems,int mode)"; 
		pointer GetBooleanArrayRegion = "void(POINTER array,int start,int l,struct &arrbuf)";
		pointer GetByteArrayRegion = "void(POINTER array,int start,int len,ptr buf)";
		pointer GetCharArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetShortArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetIntArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetLongArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetFloatArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)";
		pointer GetDoubleArrayRegion = "void(POINTER array,int start,int len,struct &arrbuf)"; 
		pointer SetBooleanArrayRegion = "void(POINTER array,int start,int l,struct buf)";
		pointer SetByteArrayRegion = "void(POINTER array,int start,int len,pointer buf)";
		pointer SetCharArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetShortArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetIntArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetLongArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetFloatArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer SetDoubleArrayRegion = "void(POINTER array,int start,int len,struct buf)";
		pointer RegisterNatives = "int(POINTER clazz,struct methods,int nMethods)"; 
		pointer UnregisterNatives = "int(POINTER clazz)";
		pointer MonitorEnter = "int(POINTER obj)";
		pointer MonitorExit = "int(POINTER obj)";
		pointer GetJavaVM = "int(pointer &vm)";
		pointer GetStringRegion = "void(POINTER  str,int start,int len,pointer buf)";
		pointer GetStringUTFRegion = "void(POINTER  str,int start,int len,pointer buf)";
		pointer GetPrimitiveArrayCritical = "pointer (POINTER array,BYTE &isCopy)";
		pointer ReleasePrimitiveArrayCritical = "void(POINTER array,pointer carray,int mode)";
		pointer GetStringCritical = "pointer (POINTER  string,BYTE &isCopy)";
		pointer ReleaseStringCritical = "void(POINTER  string,pointer cstring)";
		pointer NewWeakGlobalRef = "pointer(POINTER obj)";
		pointer DeleteWeakGlobalRef = "void(POINTER ref)";
		pointer ExceptionCheck = "bool()";
		pointer NewDirectByteBuffer = "pointer(POINTER address,long capacity)";
		pointer GetDirectBufferAddress = "pointer(POINTER buf)";
		pointer GetDirectBufferCapacity = "long(POINTER buf)";
		pointer GetObjectRefType = "int(POINTER obj)"
    }
    
    var typename_signature2jni = {
		pointer = "Object";
		BOOL = "Boolean";
		bool = "Boolean";
		boolean = "Boolean";
		CHAR = "Char";
		char = "Char";
		WORD = "Char";
		SHORT = "Short";
		short = "Short";
		word = "Short";
		int = "Int";
		INT = "Int";
		long = "Long";
		LONG = "Long";
		string = "Object";
		BYTE= "Byte";
		byte = "Byte";
		float = "Float";
		double = "Double";
		void = "Void";
		long64 = "Long";
		float32 = "Float";
		float64 = "Double";
		int8 = "Byte";
		int16 = "Short";
		int32 = "Int";
		int64 = "Long";
	}
	
	var typename_signature2canonical = {
		Z = "BYTE";
		B = "byte";
		C = "WORD";
		S = "word";
		I = "int";
		J = "long";
		D = "double";
		F = "float"; 
		["java.lang.String"] = "string"; 
		["java/lang/String"] = "string"; 
	}
	
	signatureTypeToJniType = function(t){
		if(!#t) return "Void"; 
		if( ..string.find(t,"\;") ) return "Object"; 
		return typename_signature2jni[t] || "Object"
	} 
	
	signatureTypeToCanonicalType = function(t){
		if( typename_signature2jni[t] ) return t;
		t = typename_signature2canonical[t];
		if( t ) return t;
		return "pointer";
	}
	
	convertSignature = function(sign){
		if( ..string.find(sign,"\s") ) error("Java 签名中仅可指定类型名称,不能包含空格或参数名字",2)
		var replace = ..string.replace;
		
		sign = replace(sign,"![\w\./\\]void![\W]","V");
		sign = replace(sign,"![\w\./\\]<bool>|<BOOL>|<boolean>![\W]","Z"); 
		sign = replace(sign,"![\w\./\\]<byte>|<BYTE>|<int8>![\W]","B"); 
		sign = replace(sign,"![\w\./\\]<char>|<CHAR>|<WORD>![\W]","C");
		sign = replace(sign,"![\w\./\\]<short>|<SHORT>|<word>|<int16>![\W]","S");
		sign = replace(sign,"![\w\./\\]<int>|<INT>|<int32>![\W]","I"); 
		sign = replace(sign,"![\w\./\\]<long>|<LONG>|<int64>|<long64>![\W]","J");
		sign = replace(sign,"![\w\./\\]<float>|<float32>![\W]","F");
		sign = replace(sign,"![\w\./\\]<double>|<float64>![\W]","D");
		sign = replace(sign,"![\w\./\\]([\w\\/\.\$]+)\s*\[\s*\]","[\1"); //[数组 
		sign = replace(sign,"![\w\./\\]string![\W]","java/lang/String"); 
		sign = replace(sign,"![\w\./\\]STRING![\W]","java/lang/String"); 
		sign = replace(sign,"![\w\./\\]<pointer>|<POINTER>|<object>|<Object>![\W]","java/lang/Object"); 
		sign = replace(sign,"![\w]([\w\\/\.\$]{2,})![\W]","L\1;"); //L+类名+;
		
		sign = replace(sign,"\\","/");
		sign = replace(sign,"\.","/");  
		sign = replace(sign,"(.+)(%())","\2\1") ; 
		sign = replace(sign,"\,",""); 

		return sign;
	}
	
	class jvalue{
		union v = {
    		BYTE jboolean;
    		byte jbyte;
    		WORD jchar;
    		word jshort;
    		int jint;
    		long jlong;
    		float jfloat;
    		double jdouble;
    		pointer jobject;
		}
	}
}

import java.class;
import java.object;

//@guide [📄 aardio + Java 开发指南](doc://library-guide/std/java/_.md)

/**intellisense() 
java( = 创建 JAVA 虚拟机,仅支持 32 位 JRE。\n改用 java.openProcess  函数可兼容 32位、64位 JRE。\n如果未找到可用的 JVM 运行库返回 null\n在每个进程第一次创建JAVA 虚拟机或初始化 JVM 路径之前,\n可调用 java.path.setJreHome 自定义搜索 JVM 的 JRE 运行时目录,\njar包搜索顺序为"\","\java\","~\java",\n可使用 java.addClassPath 函数添加搜索路径
java(.(命令行参数,->->->) = n可指定一个或多个启动命令行参数,\n也可以把多个参数写到一个字符串参数或数组参数里,\n\n参数类似 "-D<propertyName>=value"\n在 JAVA 中可以使用 System.getProperty("propertyName") 得到value的值\n\n对于每个打开的进程,JAVA虚拟机仅创建一次实例,\n因此所有参数、搜索路径等仅在首次创建虚拟机时生效
java() = !java.
java.encoding = 指定默认编码,\n默认值为 "utf-8",\nUTF-8 目前是最好也是最通用的设置,\n最好不要改也不必要改
java.openProcess(.("-jar","命令行参数", ->->-> ) = 创建Java窗口应用程序返回process进程对象\n命令行参数可以是数组或任意个文本参数,\n如果命令行参数有多个,则包含空格的参数添加必要的双引号和转义,\n如果参数@1是数组,\n参数@2可指定 process.STARTUPINFO 结构体或部分字段,\n规则考 process 构造函数
java.openProcess() = !process.
java.popenProcess(.("-jar","命令行参数", ->->-> ) = 创建Java控制台应用程序返回process.popen对象\n命令行参数可以是数组或任意个文本参数,\n如果命令行参数有多个,则包含空格的参数添加必要的双引号和转义,\n如果参数@1是数组,\n参数@2可指定 process.STARTUPINFO 结构体或部分字段,\n规则考 process 构造函数
java.popenProcess() = !process_popen.
java.compile(.("java源文件路径") = 编译java源文件\n该函数需要系统安装JDK,可事先设置JAVA_HOME环境变量手动指定JDK位置\n注意如果aardio自带了jre版本必须与JDK一致,不然java程序编译后可能无法运行
java.compile() = !process_popen.
java.addClassPath(__) = 添加一个或多个查找类的根目录\n添加该目录时将自动添加该目录下已存在的 *.jar 文件\n子目录下的jar文件将被忽略\n注意:必须在进程首次创建 Java 虚拟机之前调用该函数
java.addLibPath(__) = 添加一个或多个目录\nJava中调用System.loadLibrary()时将在指定的目录查找DLL组件
java.version = JVM 虚拟机接口版本,\n在进程首次创建虚拟机以前用于指定最低兼容版本\n默认会设为 0x10006/*_JNI_VERSION_1_6*/
java.runtimeVersion(true) = 返回 Java 运行时版号，数值。\n版本号为 1.x 时返回第 2 位版本号，否则返回第 1 位版本号（Java 9 以上）。\n如果不指定参数，则返回字符串格式的完整版本号。
!java.version =  JVM 虚拟机接口版本,\nJava 8 的接口版本为 0x10008/*_JNI_VERSION_1_8*/,\n目前 Java 10+ 的接口版本号都是 0xa0000/*JNI_VERSION_10*/
!java.__isMainThread = 仅第一次创建java虚拟机时该值为true,\n随后创建的虚拟机都会返回false
!java.addClassLoaderUrl( = 添加类搜索目录到 CLASSPATH,\n此函数仅支持 Java6~Java8 \nJava9 开始不再支持,可以改用 java.addClassPath,\n但 java.addClassPath 仅支持 ANSI编码路径,\naddClassLoaderUrl 函数支持 UTF-8 编码路径
!java.addClassLoaderUrl(.("类搜索路径") = 添加jar包或文件目录到 CLASSPATH,\nJava 在 CLASSPATH 指定的目录或 jar 中搜索类,\n参数可以是一个数组,也可以是多个路径参数
!java.import( = 导入并返回 Java 类。
!java.import(.("类名","类文件路径") = 导入 Java 类。\n可选用参数 @2 指定 *.class 文件路径（或指定文件数据并内存加载类）。\n导入成功则返回值为导入的 Java 类，可使用返回的类直接构造 Java 对象。\n如果类不存在或加载失败返回 null 空值 - 不会抛出异常。\n\n注意此函数需要通过返回值接收导入的 Java 类，\n并不会像 dotNet.import 那样自动导入外部名字空间。
!java.exceptionClear() = 该函数如果检测到抛出的异常,并清除异常返回true\n如果未检测到异常返回空值
!java.array("int",__) = 将一个或多个基本类型转换为java数组对象\n传入参数也可以是一个table类型字符串数组
!java.stringArray(__) = 将一个或多个字符串转换为java字符串数组\n传入参数也可以是一个table类型字符串数组
!java.string(__) = 将aardio字符串转换为java字符串对象\n返回对象指针
!java.hashMap(__) = 创建 java.util.HashMap 对象，返回 Java 对象（java.object）。\n参数可指定普通的 aardio 表对象。\n\n注意：在调用 java 函数时，\n除 java.object,纯数组,类数组,时间对象以外的表\n也会自动转换为 java.util.HashMap 对象。\n但 Java 返回的 HashMap 不会自动转换为 aardio 表，\n需要显式调用 java 对象的 parseValue 才会转换为 aardio 表。
!java.buffer(__) = 创建 Java 字节数组，返回 Java 对象（java.object）。\n参数可指定 aardio 的 buffer 或字符串对象。
!java.double(__) = 创建 64 位浮点数值，返回 Java 对象（java.object）。
!java.float(__) = 创建 32 位浮点数值，返回 Java 对象（java.object）。
!java.char(__) = 创建 16 位无符号整型数值（java.lang.Character），返回 Java 对象（java.object）。
!java.byte(__) = 创建 8 位整型数值，返回 Java 对象（java.object）。
!java.short(__) = 创建 16 位整型数值，返回 Java 对象（java.object）。
!java.int(__) = 创建 32 位整型数值，返回 Java 对象（java.object）。
!java.long(__) = 创建 64 位整型数值，返回 Java 对象（java.object）。
!java.long(__) = 创建 64 位整型数值，返回 Java 对象（java.object）。
!java.date(__) = 创建 java.util.Date 对象，返回 Java 对象（java.object）。\n参数可指定时间戳或 time,time.ole 对象。\n不指定参数时获取当前时间戳作为参数。\n\n在 aardio 中调用 Java 函数时，time,time.ole 对象会自动转换为 java.util.Date。\nJava 返回的 java.util.Date 也会自动转换为 aardio 的 time 对象。
!java.parseString(__) = 将 Java 字符串转换为 aardio 字符串。\n注意:该函数会销毁传入的 Java 对象指针
!java.parseStringArray(.(java数组) = 将 Java 对象指针转换为 aardio 数组对象\n注意:该函数会销毁传入的 Java 对象指针
!java.parseArray(.("int",java数组)  = 将 Java 对象指针转换为 aardio 数组对象,参数一指定数组元素数据类型\n注意:该函数会销毁传入的 Java 对象指针
!java.parseObject(.(jobject) = 将参数指定的 jobject 指针转换为 java.object 对象。\n支持转换的对象可调用 java.object 对象 parseValue 方法转换为纯 aardio 值。
!java.invokeMethod(.(类或对象,其他调用参数->->->) = 调用Java函数,支持多个参数\n对于数值类型,aardio将会自动检测适用的数值类型\n也可以调用java.int,java.short,java.char,java.long等函数显式的声明数值类型
!java.interop = aardio.interopServices.utility类
!java.fieldExists(.(Java对象,"字段名") = 返回是否存在指定字段名
!java.getFieldValue(.(Java对象,"字段名") = 返回字段值
!java.setFieldValue(.(Java对象,"字段名",字段值) = 修改字段值
!java.new(.(java类对象,->->->) = 调用构造函数创建对象
!java.objectIsNumber(__) = 返回参数指定的Java对象是否数值
!java.objectIsString(__) = 返回参数指定的Java对象是否字符串
!java.object2Number(__) = java数值对象转换为 aardio 数值
!java.object2String(__) = java字等串对象转换为 aardio 字符串
!java.reopen("setErr","conerr$") = 重定向错误输出到控制台
!java.reopen("setOut","conout$") = 重定向标准输出到控制台,\n如果在创建 Java 虚拟机以后打开控制台,\n需要调用此函数才能在控制台看到 Java 的标准输出
!java.loadFileObject(__) = 自参数 @1 指定的文件路径反序化化 Java 对象
!java.import() = !stdJavaClass.
!stdJavaClass.registerNative(函数,函数名,签名) = @.registerNative(\n	function(env,jobject,jstring){\n		var str = owner.parseString(jstring)\n		\n		return owner.string( func() )\n	},"__/*函数名*/","string(string)"\n)
!stdJavaClass.unregisterNatives() = 注销所有注册到 Java 类中的函数
!stdJavaClass.getField(.("字段名","int") = 参数 @2 指定字段类型声明\n与函数原型使用的语法一致
!stdJavaClass.getMethod(.("函数名","int(int)") = 返回 Java 类的静态成员函数。\n参数 @2 指定[函数签名](doc://library-guide/std/java/_.md#signature)。\n\n不需要调用 getMethod 也可以直接调用类的静态成员函数。\n但指定签名可以直接获取指定函数并省略了自动匹配过程。
!stdJavaClass.new(.(->->->) = 使用 Java 调用构造函数创建对象，可指定不定个数的参数。\nnew 方法是类的默认方法可以省略不写直接用 Java 类构造 Java 对象。\n\n改用 new2 函数构造对象可以用第 1 个参数显式指定构造函数签名。
!stdJavaClass.new2(.("void()"->->->) = 使用 JNI 调用构造函数创建对象。\n参数 @1 指定[构造函数签名](doc://library-guide/std/java/_.md#signature)，签名里的返回值必须指定为 void 类型。\n参数 @2 开始可指定不定个数的构造参数（new2 名字后面的 2 指示这一要点）。\n此函数的实际返回值为构造的 Java 实例对象（不用管签名里的返回值）。\n\n使用类的 new 方法也可以构造 Java 对象。\n并且可以省略 new 是默认方法名可以省略，可直接用 Java 类构造 Java 对象。
!stdJavaClass.new2() = !stdJavaObject.
!stdJavaClass.? = Java 类的静态属性或方法。
!stdJavaClass() = !stdJavaObject.
!stdJavaObject.getMethod(.("函数名","int(int)") = 返回 Java 对象的成员函数。\n参数 @2 指定[函数签名](doc://library-guide/std/java/_.md#signature)。\n省略签名则默认设为 `"void()"`。\n注意 Java 区分大小写，返回的函数支持任意个数参数。\n\n不需要调用 getMethod 也可以直接调用类的静态成员函数。\n但指定签名可以直接获取指定函数并省略了自动匹配过程。
!stdJavaObject.getField("字段名__","int") = 第二个参数指定字段类型声明。\n与函数[函数签名](doc://library-guide/std/java/_.md#signature)支持的类型相同。
_JNI_VERSION_1_1=@0x10001/*_JNI_VERSION_1_1*/
_JNI_VERSION_1_2=@0x10002/*_JNI_VERSION_1_2*/
_JNI_VERSION_1_4=@0x10004/*_JNI_VERSION_1_4*/
_JNI_VERSION_1_6=@0x10006/*_JNI_VERSION_1_6*/
_JNI_VERSION_1_7=@0x10007/*_JNI_VERSION_1_7*/
_JNI_VERSION_1_8=@0x10008/*_JNI_VERSION_1_8*/
_JNI_VERSION_9=@0x90000/*_JNI_VERSION_9*/
_JNI_VERSION_10=@0xA0000/*_JNI_VERSION_10*/
_JNI_VERSION_11=@0xB0000/*_JNI_VERSION_11*/
_JNI_VERSION_12=@0xC0000/*_JNI_VERSION_12*/
_JNI_VERSION_13=@0xD0000/*_JNI_VERSION_13*/
_JNI_VERSION_14=@0xE0000/*_JNI_VERSION_14*/
_JNI_VERSION_15=@0xF0000/*_JNI_VERSION_15*/
_JNI_FALSE = @0/*_JNI_FALSE*/
_JNI_TRUE = @1/*_JNI_TRUE*/
end intellisense**/